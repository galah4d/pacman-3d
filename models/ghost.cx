package main

import "gl"
import "glfw"

import "graphical"
import "phx"

/* Constant declaration */
var GHOST_RADIUS f32 = 0.025
var GHOST_SPAWN_LINE i32 = 14
var GHOST_SPAWN_COLLUMN i32 = 13

// Ghost Types
var GHOST_TYPE_SHADOW  i32 = 0
var GHOST_TYPE_SPEEDY  i32 = 1
var GHOST_TYPE_BASHFUL i32 = 2
var GHOST_TYPE_POKEY   i32 = 3

// Ghost modes
var GHOST_MODE_CHASE i32 = 0
var GHOST_MODE_SCATTER i32 = 1
var GHOST_MODE_FRIGHTENED i32 = 2
var GHOST_MODE_IN_HOUSE i32 = 3

// Ghost Scatter Points
var SHADOW_SCATTER_LINE     i32 = 2
var SHADOW_SCATTER_COLLUMN  i32 = 26
var SPEEDY_SCATTER_LINE     i32 = 2
var SPEEDY_SCATTER_COLLUMN  i32 = 1
var BASHFUL_SCATTER_LINE    i32 = 28
var BASHFUL_SCATTER_COLLUMN i32 = 26
var POKEY_SCATTER_LINE      i32 = 28
var POKEY_SCATTER_COLLUMN i32 = 1

var GHOST_TEXTURES [4] i32

var GHOST_MOVEMENT_TIMER f64 = 0.001D
//var GHOST_RELEASE_TIMER f64 = 5.0D
var GHOST_FRIGHTENED_TIMER f64 = 10.0D

var GHOST_RELEASE_TIMER [4]f64 = [4]f64{5.0D, 10.0D, 15.0D, 20.0D}

var g_ghosts[4]Ghost

type Ghost struct {
  index_x i32
  index_y i32
  gtype i32
  mode i32

  direction phx.Direction
  next_direction phx.Direction
  velocity f32

  head_geometry graphical.SphereGeometry
  body_geometry graphical.CylinderGeometry

  movement_timer f64
  release_timer f64
  frightened_timer f64
}

func NewGhost(line i32, collumn i32, gtype i32) (ghost Ghost) {
  ghost.index_x = collumn
  ghost.index_y = line
  ghost.gtype = gtype
  ghost.mode = GHOST_MODE_IN_HOUSE

  ghost.velocity = 0.005

  ghost.movement_timer = 0.0D
  ghost.release_timer = GHOST_RELEASE_TIMER[gtype]
  ghost.frightened_timer = 0.0D

  var mat graphical.Material
  mat = graphical.newMaterial(1.0, 0.0, 0.0) // Red color
  mat = mat.setTexture(GHOST_TEXTURES[ghost.gtype])

  ghost.head_geometry = graphical.newSphereGeometry(GHOST_RADIUS, 5, mat)
  //ghost.body_geometry = graphical.newCylinderGeometry(GHOST_RADIUS, GHOST_RADIUS, mat)

  ghost.head_geometry.position = getPosition3D(ghost.index_y, ghost.index_x)
  //ghost.body_geometry.position.y = f32.sub(position.y, GHOST_RADIUS)
}

// Initializes the ghosts
func InitGhosts() {
  loadGhostTextures()

  for i:=0; i<4; i++ {
    g_ghosts[i] = NewGhost(GHOST_SPAWN_LINE, GHOST_SPAWN_COLLUMN, i)
  }
}

// Loads the ghosts textures
func loadGhostTextures () {
  GHOST_TEXTURES[GHOST_TYPE_SHADOW] = gl.NewTexture("textures/ghosts/ghost.jpg")
  GHOST_TEXTURES[GHOST_TYPE_SPEEDY] = gl.NewTexture("textures/ghosts/ghost2.jpg")
  GHOST_TEXTURES[GHOST_TYPE_BASHFUL] = gl.NewTexture("textures/ghosts/ghost3.jpg")
  GHOST_TEXTURES[GHOST_TYPE_POKEY] = gl.NewTexture("textures/ghosts/ghost4.jpg")
}

func GhostUpdate(ghost Ghost, time f64) (ghost Ghost) {
  if ghost.mode == GHOST_MODE_FRIGHTENED {
    if GHOST_FRIGHTENED_TIMER <= f64.sub(time, ghost.frightened_timer) {
      ghost.mode = GHOST_MODE_CHASE
    }
  }

  // Incarcerates the ghost
  if bool.and(i32.eq(ghost.index_x, g_player.index_x), i32.eq(ghost.index_y, g_player.index_y)) {
    if ghost.mode == GHOST_MODE_FRIGHTENED {
      ghost = GhostIncarcerate(ghost)
      ghost.release_timer = time

    } else {
      InitPlayer()
      // TODO @galah4d implement PlayerDie()
    }
  }

  // Releases the ghost
  if GHOST_RELEASE_TIMER[0] <= f64.sub(time, ghost.release_timer) {
    if ghost.mode == GHOST_MODE_IN_HOUSE {
      ghost = GhostRelease(ghost)
    }
    //ghost.release_timer = time
  }

  // Moves the ghost
  if GHOST_MOVEMENT_TIMER <= f64.sub(time, ghost.movement_timer) {
    ghost = GhostMove(ghost, g_player.index_y, g_player.index_x)
    ghost.movement_timer = time
  }
}

func GhostRelease(ghost Ghost) (ghost Ghost) {
  ghost.mode = GHOST_MODE_CHASE

  ghost.index_x = 14
  ghost.index_y = 11

  ghost.head_geometry.position = getPosition3D(ghost.index_y, ghost.index_x)
  ghost.direction = calculateGhostDirection(ghost, g_player.index_y, g_player.index_y)
}

func GhostIncarcerate(ghost Ghost) (ghost Ghost) {
  ghost.mode = GHOST_MODE_IN_HOUSE

  ghost.index_x = 14
  ghost.index_y = 13

  ghost.head_geometry.position = getPosition3D(ghost.index_y, ghost.index_x)
  ghost.direction = calculateGhostDirection(ghost, g_player.index_y, g_player.index_y)
}

func (ghost Ghost) frighten () (ghost Ghost) {
  ghost.mode = GHOST_MODE_FRIGHTENED
  //ghost.head_geometry.material = graphical
}

func GhostMove(ghost Ghost, player_collumn i32, player_line i32) (ghost Ghost) {
  new_line := i32.add(ghost.index_y, f32.i32(ghost.direction.vector.y))
  new_collumn := i32.add(ghost.index_x, f32.i32(ghost.direction.vector.x))

  ghost.head_geometry.position = phx.VectorAdd(ghost.head_geometry.position, phx.VectorMulScalar(ghost.direction.vector, ghost.velocity))

  if phx.VectorDistance(ghost.head_geometry.position, g_board.cells[new_line][new_collumn].geometry.position) < 0.005 {
    //printf("Ghost %d index update - Mode %d\n", ghost.gtype, ghost.mode)
    ghost.index_y = new_line
    ghost.index_x = new_collumn

    ghost.direction = calculateGhostDirection(ghost, player_collumn, player_line)
  }
}

func GhostRender(ghost Ghost) {
  var hg graphical.SphereGeometry
  hg = ghost.head_geometry

  //var bg graphical.CylinderGeometry
  //bg = ghost.body_geometry

  hg.render()
  //bg.render()
}

// TODO pass player as agr
func calculateGhostDirection(ghost Ghost, target_line i32, target_collumn i32) (direction phx.Direction) {
  //direction = phx.DirectionRight()

  //printf("Line: %d | Collumn:%d\n", ghost.index_y, ghost.index_x)

  if ghost.mode == GHOST_MODE_CHASE {
    var min_cost f32 = 1000.0 // Infinite

    var cost f32
    var valid bool

    cost, valid = calculateDirectionCost(ghost, phx.DirectionUp())
    if valid && cost < min_cost {
      min_cost = cost
      direction = phx.DirectionUp()
    }

    cost, valid = calculateDirectionCost(ghost, phx.DirectionDown())
    if valid && cost < min_cost {
      min_cost = cost
      direction = phx.DirectionDown()
    }

    cost, valid = calculateDirectionCost(ghost, phx.DirectionLeft())
    if valid && cost < min_cost {
      min_cost = cost
      direction = phx.DirectionLeft()
    }

    cost, valid = calculateDirectionCost(ghost, phx.DirectionRight())
    if valid && cost < min_cost {
      min_cost = cost
      direction = phx.DirectionRight()
    }

  } else if ghost.mode == GHOST_MODE_IN_HOUSE {
    var directions [4]phx.Direction
    directions[0] = phx.DirectionUp()
    directions[1] = phx.DirectionDown()
    directions[2] = phx.DirectionLeft()
    directions[3] = phx.DirectionRight()

    direction = directions[i32.rand(0, 4)]
    for bool.not(GhostCanMove(ghost, direction)) {
      direction = directions[i32.rand(0, 4)]
    }
  }
}

// TODO pass player as arg
func calculateDirectionCost(ghost Ghost, direction phx.Direction) (cost f32, valid bool) {
  valid = GhostCanMove(ghost, direction)
  if valid {
    cost = phx.VectorDistance(
      phx.VectorAdd(ghost.head_geometry.position, direction.vector),
      g_player.geometry.position)
  } else {
    cost = 1000.0 // Infinite
  }
}

func GhostCanMove(ghost Ghost, direction phx.Direction) (out bool) {
  new_line := i32.add(ghost.index_y, f32.i32(direction.vector.y))
  new_collumn := i32.add(ghost.index_x, f32.i32(direction.vector.x))

  out = bool.and(
    i32.eq(g_board.cells[new_line][new_collumn].ctype, CELL_TYPE_PATH),
    bool.not(phx.DirectionEq(phx.DirectionOpposite(ghost.direction), direction)))
}
