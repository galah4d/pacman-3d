package main

import "gl"
import "glfw"

import "graphical"

/* Constant declaration */
var GHOST_RADIUS f32 = 0.025
var GHOST_SPAWN_LINE i32 = 11
var GHOST_SPAWN_COLLUMN i32 = 13

// Ghost Types
var GHOST_TYPE_SHADOW  i32 = 0
var GHOST_TYPE_SPEEDY  i32 = 1
var GHOST_TYPE_BASHFUL i32 = 2
var GHOST_TYPE_POKEY   i32 = 3

// Ghost modes
var GHOST_MODE_CHASE i32 = 0
var GHOST_MODE_SCATTER i32 = 1
var GHOST_MODE_FRIGHTENED i32 = 2
var GHOST_MODE_IN_HOUSE i32 = 3

// Ghost Scatter Points
var SHADOW_SCATTER_LINE     i32 = 2
var SHADOW_SCATTER_COLLUMN  i32 = 26
var SPEEDY_SCATTER_LINE     i32 = 2
var SPEEDY_SCATTER_COLLUMN  i32 = 1
var BASHFUL_SCATTER_LINE    i32 = 28
var BASHFUL_SCATTER_COLLUMN i32 = 26
var POKEY_SCATTER_LINE      i32 = 28
var POKEY_SCATTER_COLLUMN i32 = 1

var GHOST_TEXTURES [4] i32

var GHOST_MOVEMENT_TIMER f64 = 1.0D
//var GHOST_RELEASE_TIMER f64 = 5.0D
var GHOST_FRIGHTENED_TIMER f64 = 10.0D

var GHOST_RELEASE_TIMER [4]f64 = [4]f64{5.0D, 10.0D, 15.0D, 20.0D}

type Ghost struct {
  index_x i32
  index_y i32
  direction i32
  gtype i32
  mode i32

  head_geometry graphical.SphereGeometry
  body_geometry graphical.CylinderGeometry

  movement_timer f64
  release_timer f64
  frightened_timer f64
}

func newGhost (line i32, collumn i32, gtype i32) (ghost Ghost) {
  ghost = Ghost{
    index_x: collumn,
    index_y: line,
    gtype: gtype,
    mode: GHOST_MODE_IN_HOUSE,
    movement_timer: 0.0D,
    release_timer: GHOST_RELEASE_TIMER[gtype],
    frightened_timer: 0.0D}

  var mat graphical.Material
  mat = graphical.newMaterial(1.0, 0.0, 0.0) // Red color
  mat = mat.setTexture(GHOST_TEXTURES[ghost.gtype])

  ghost.head_geometry = graphical.newSphereGeometry(GHOST_RADIUS, 20, mat)
  //ghost.body_geometry = graphical.newCylinderGeometry(GHOST_RADIUS, GHOST_RADIUS, mat)

  ghost.head_geometry.position = getPosition3D(ghost.index_y, ghost.index_x)
  //ghost.body_geometry.position.y = f32.sub(position.y, GHOST_RADIUS)

  return ghost
}

func (ghost Ghost) update (time f64) (ghost Ghost) {
  if ghost.mode == GHOST_MODE_FRIGHTENED {
    if GHOST_FRIGHTENED_TIMER <= f64.sub(time, ghost.frightened_timer) {
      ghost.mode = GHOST_MODE_CHASE
    }
  }

  // Incarcerates the ghost
  if bool.and(i32.eq(ghost.index_x, player.index_x), i32.eq(ghost.index_y, player.index_y)) {
    ghost = ghost.incarcerate()
    ghost.release_timer = time
  }

  // Releases the ghost
  if GHOST_RELEASE_TIMER[0] <= f64.sub(time, ghost.release_timer) {
    if ghost.mode == GHOST_MODE_IN_HOUSE {
      ghost = ghost.release()
    }
    //ghost.release_timer = time
  }

  // Moves the ghost
  if GHOST_MOVEMENT_TIMER <= f64.sub(time, ghost.movement_timer) {
    ghost = ghost.move()
    ghost.movement_timer = time
  }
}

func (ghost Ghost) release () (ghost Ghost) {
  ghost.index_x = GHOST_SPAWN_COLLUMN
  ghost.index_y = GHOST_SPAWN_LINE
  ghost.mode = GHOST_MODE_CHASE
}

func (ghost Ghost) incarcerate () (ghost Ghost) {
  ghost.index_x = 14
  ghost.index_y = 13
  ghost.mode = GHOST_MODE_IN_HOUSE
}

func (ghost Ghost) frighten () (ghost Ghost) {
  ghost.mode = GHOST_MODE_FRIGHTENED
  //ghost.head_geometry.material = graphical
}

func (ghost Ghost) move () (ghost Ghost) {
  ghost.direction = ghost.calculateDirection()

  if i32.eq(ghost.direction, UP) {
    ghost.index_y = i32.sub(ghost.index_y, 1)
  }
  if i32.eq(ghost.direction, DOWN) {
    ghost.index_y = i32.add(ghost.index_y, 1)
  }
  if i32.eq(ghost.direction, LEFT) {
    ghost.index_x = i32.sub(ghost.index_x, 1)
  }
  if i32.eq(ghost.direction, RIGHT) {
    ghost.index_x = i32.add(ghost.index_x, 1)
  }
  // Update ghost position
  ghost.head_geometry.position = getPosition3D(ghost.index_y, ghost.index_x)
}

func (ghost Ghost) calculateDirection() (direction i32) {
  // Calculates the ghost moving direction depending on the current mode mode
  if i32.eq(ghost.mode, GHOST_MODE_CHASE) {
    direction = calculateGhostDirection(ghost, player.index_x, player.index_y)

  } else if i32.eq(ghost.mode, GHOST_MODE_SCATTER) {
    if i32.eq(ghost.gtype, GHOST_TYPE_SHADOW) {
      direction = calculateGhostDirection(ghost, SHADOW_SCATTER_LINE, SHADOW_SCATTER_COLLUMN)

    } else if i32.eq(ghost.gtype, GHOST_TYPE_SPEEDY) {
      direction = calculateGhostDirection(ghost, SPEEDY_SCATTER_LINE, SPEEDY_SCATTER_COLLUMN)

    } else if i32.eq(ghost.gtype, GHOST_TYPE_BASHFUL) {
      direction = calculateGhostDirection(ghost, BASHFUL_SCATTER_LINE, BASHFUL_SCATTER_COLLUMN)

    } else if i32.eq(ghost.gtype, GHOST_TYPE_POKEY) {
      direction = calculateGhostDirection(ghost, POKEY_SCATTER_LINE, POKEY_SCATTER_COLLUMN)
    }

  // Calculates a random valid position
  } else if bool.or(i32.eq(ghost.mode, GHOST_MODE_FRIGHTENED), i32.eq(ghost.mode, GHOST_MODE_IN_HOUSE)) {
    direction = i32.rand(0, 4)
    for bool.not(bool.and(bool.not(i32.eq(direction, reverseDirection(ghost.direction))), canMove(direction, ghost.index_y, ghost.index_x))) {
      direction = i32.rand(0, 4)
    }
  }
}

func (ghost Ghost) render () {
  var hg graphical.SphereGeometry
  hg = ghost.head_geometry

  //var bg graphical.CylinderGeometry
  //bg = ghost.body_geometry

  hg.render()
  //bg.render()
}

func loadGhostTextures () {
  GHOST_TEXTURES[GHOST_TYPE_SHADOW] = gl.NewTexture("textures/ghosts/ghost.jpg")
  GHOST_TEXTURES[GHOST_TYPE_SPEEDY] = gl.NewTexture("textures/ghosts/ghost2.jpg")
  GHOST_TEXTURES[GHOST_TYPE_BASHFUL] = gl.NewTexture("textures/ghosts/ghost3.jpg")
  GHOST_TEXTURES[GHOST_TYPE_POKEY] = gl.NewTexture("textures/ghosts/ghost4.jpg")
}

func calculateGhostDirection(ghost Ghost, target_line i32, target_collumn i32) (direction i32) { // FIX ME no spaghetti code
  var min_distance i32 = 100 // Infinite

  var distance_left i32
  if bool.and(bool.not(i32.eq(ghost.direction, RIGHT)), canMove(LEFT, ghost.index_y, ghost.index_x)) {
    distance_left = i32.add(i32.abs(i32.sub(target_collumn, i32.sub(ghost.index_x, 1))), i32.abs(i32.sub(target_line, ghost.index_y)))
    if i32.lt(distance_left, min_distance) {
      min_distance = distance_left
      direction = LEFT
    }
  }

  var distance_right i32
  if bool.and(bool.not(i32.eq(ghost.direction, LEFT)), canMove(RIGHT, ghost.index_y, ghost.index_x)) {
    distance_right = i32.add(i32.abs(i32.sub(target_collumn, i32.add(ghost.index_x, 1))), i32.abs(i32.sub(target_line, ghost.index_y)))
    if i32.lt(distance_right, min_distance) {
      min_distance = distance_right
      direction = RIGHT
    }
  }

  var distance_up i32
  if bool.and(bool.not(i32.eq(ghost.direction, DOWN)), canMove(UP, ghost.index_y, ghost.index_x)) {
    distance_up = i32.add(i32.abs(i32.sub(target_collumn, ghost.index_x)), i32.abs(i32.sub(target_line, i32.sub(ghost.index_y, 1))))
    if i32.lt(distance_up, min_distance) {
      min_distance = distance_up
      direction = UP
    }
  }

  var distance_down i32
  if bool.and(bool.not(i32.eq(ghost.direction, UP)), canMove(DOWN, ghost.index_y, ghost.index_x)) {
    distance_down = i32.add(i32.abs(i32.sub(target_collumn, ghost.index_x)), i32.abs(i32.sub(target_line, i32.add(ghost.index_y, 1))))
    if i32.lt(distance_down, min_distance) {
      min_distance = distance_down
      direction = DOWN
    }
  }

  return direction
}

func reverseDirection(direction i32) (reverse i32) {
  var reverse i32

  if i32.eq(direction, UP) {
    reverse = DOWN
  }
  if i32.eq(direction, DOWN) {
    reverse = UP
  }
  if i32.eq(direction, LEFT) {
    reverse = RIGHT
  }
  if i32.eq(direction, RIGHT) {
    reverse = LEFT
  }

  return reverse
}
