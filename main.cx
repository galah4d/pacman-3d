package main

// Import core packages
import "gl"
import "glfw"
import "os"

// Import custom packages
import "graphical"
import "image_pkg"
import "button_pkg"
import "textbox_pkg"
import "layer_pkg"
import "screen_pkg"

// Keyboard Keys
var RIGHT_ARROW_KEY i32 = 262
var LEFT_ARROW_KEY i32 = 263
var DOWN_ARROW_KEY i32 = 264
var UP_ARROW_KEY i32 = 265

// Directions
var UP i32 = 1
var DOWN i32 = 3
var LEFT i32 = 2
var RIGHT i32 = 0

// Screens
var SCREEN_WIDTH i32 = 1920
var SCREEN_HEIGHT i32 = 1080
var current_screen i32 = 0
var screens [5]screen_pkg.Screen

var EXIT_FLAG bool = false

/* Function     : initGLFW
   Desctription : Initializes the game window and input callback functions.
*/
func initGLFW() {
	glfw.Init()
	glfw.WindowHint(glfw.Resizable, glfw.False)
	glfw.WindowHint(glfw.ContextVersionMajor, 2)
  glfw.WindowHint(glfw.ContextVersionMinor, 1)

	glfw.CreateWindow("window", SCREEN_WIDTH, SCREEN_HEIGHT, "PACMAN 3D") // TODO add fullscreen support
	glfw.MakeContextCurrent("window")

	glfw.SetKeyCallback("window", "keyboardManager")
	//glfw.SetCursorPosCallback("window", "cursor_pos_callback")
	glfw.SetMouseButtonCallback("window", "mouse_button_callback")
}

/* Function     : initOpenGL
   Output       : OpenGL program (program i32)
   Desctription : Initializes the OpenGL lib.
*/
func initGL() (program i32) {
	gl.Init()
	gl.Enable(gl.BLEND)
  gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	gl.Enable(gl.DEPTH_TEST)
	gl.Enable(gl.TEXTURE_2D)

	program = gl.CreateProgram()
	gl.LinkProgram(program)
	return program
}

func keyboardManager(window str, key i32, scancode i32, action i32, mods i32) () {
	if current_screen == 0 {
		homeScreenKeyboardManager(window, key, scancode, action, mods)
	} else if current_screen == 1 {
		gameScreenKeyboardManager(window, key, scancode, action, mods)
	}
}

func homeScreenKeyboardManager(window str, key i32, scancode i32, action i32, mods i32) () {
	if bool.and(i32.eq(key, 256), i32.eq(action, 1)) {
    EXIT_FLAG = true
	}
}

func gameScreenKeyboardManager(window str, key i32, scancode i32, action i32, mods i32) () {
	if bool.and(i32.eq(key, RIGHT_ARROW_KEY), i32.eq(action, 1)) {
    game.player.direction = RIGHT

	} else if bool.and(i32.eq(key, LEFT_ARROW_KEY), i32.eq(action, 1)) {
		game.player.direction = LEFT

	} else if bool.and(i32.eq(key, DOWN_ARROW_KEY), i32.eq(action, 1)) {
		game.player.direction = DOWN

	} else if bool.and(i32.eq(key, UP_ARROW_KEY), i32.eq(action, 1)) {
		game.player.direction = UP
  }
}

func canMove(direction i32, line i32, collumn i32) (can_move bool)  {
  var can_move bool = false
  if bool.and(i32.eq(direction, UP), bool.not(i32.eq(game.board.cells[i32.sub(line, 1)][collumn].ctype, WALL_CELL))) {
    can_move = true
  }
  if bool.and(i32.eq(direction, DOWN), bool.not(i32.eq(game.board.cells[i32.add(line, 1)][collumn].ctype, WALL_CELL))) {
    can_move = true
  }
  if bool.and(i32.eq(direction, LEFT), bool.not(i32.eq(game.board.cells[line][i32.sub(collumn, 1)].ctype, WALL_CELL))) {
    can_move = true
  }
  if bool.and(i32.eq(direction, RIGHT), bool.not(i32.eq(game.board.cells[line][i32.add(collumn, 1)].ctype, WALL_CELL))) {
    can_move = true
  }
  return can_move
}

func mouse_button_callback(window str, key i32, action i32, mods i32) () {
	if i32.eq(action, 1) && i32.eq(key, glfw.MouseButtonLeft) {
    screens[current_screen] = screen_pkg.clickScreen(screens[current_screen])
	}
}

func cursor_pos_callback(window str, xpos f64, ypos f64) () {
	// Removed
}

/* GAME LOGIC */

var game Game

var x_cells i32 = 28
var y_cells i32 = 31
var cells [31][28]Cell

// Item Types
var PATH_CELL i32 = 3
var WALL_CELL i32 = 1
var PATH_CELL_WITH_SIMPLE_POINT i32 = 0
var PATH_CELL_WITH_SUPER_POINT i32 = 2
var TELEPORT_CELL i32 = 4
var GATE_CELL i32 = 5

func getPosition3D(line i32, collumn i32) (v graphical.Vector3f) {
  x := f32.add(-1.0, f32.add(f32.mul(i32.f32(collumn), CELL_WIDTH), f32.div(CELL_WIDTH, 2.0)))
  y := f32.add(-1.0, f32.add(f32.mul(i32.f32(line), CELL_HEIGHT), f32.div(CELL_HEIGHT, 2.0)))
	v = graphical.newVector3f(x, y, 0.0)
  return v
}

func main () () {
	initGLFW()
	var program i32
	program = initGL()

	// Initializes all the screens
	screens[0] = newHomeScreen(SCREEN_WIDTH, SCREEN_HEIGHT)
	screens[1] = newGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT)
	screens[2] = newPauseScreen(SCREEN_WIDTH, SCREEN_HEIGHT)
	screens[3] = newSettingsScreen(SCREEN_WIDTH, SCREEN_HEIGHT)
	screens[4] = newGraphicalSettingsScreen(SCREEN_WIDTH, SCREEN_HEIGHT)

	game = initGame()

	var x f64
  var y f64
	for bool.not(glfw.ShouldClose("window")) {
		// Home screen
		if current_screen == 0 {
			for j:=0; j<len(screens[0].layers); j++ {
				if screens[0].layers[j].pending_callback {
		      screens[0].layers[j].pending_callback = false

					if str.eq(screens[0].layers[j].callback_id, "play-button") {
						current_screen = 1
					} else if str.eq(screens[0].layers[j].callback_id, "settings-button") {
						current_screen = 3
					}
		    }
			}

		// Game screen
		} else if current_screen == 1 {
			for j:=0; j<len(screens[1].layers); j++ {
				if screens[1].layers[j].pending_callback {
		      screens[1].layers[j].pending_callback = false

					if str.eq(screens[1].layers[j].callback_id, "pause-button") {
						current_screen = 2
					}
					// FIXME @galah4d redirect to home screen, OpenGl crashes.
					/*else if str.eq(screens[2].layers[j].callback_id, "exit-button") {
						current_screen = 0
					}*/
		    }
			}
			game = game.update()

		// Pause screen
		} else if current_screen == 2 {
			for j:=0; j<len(screens[2].layers); j++ {
				if screens[2].layers[j].pending_callback {
		      screens[2].layers[j].pending_callback = false

					if str.eq(screens[2].layers[j].callback_id, "resume-button") {
						current_screen = 1
					}
					// FIXME @galah4d redirect to home screen, OpenGl crashes.
					/*else if str.eq(screens[2].layers[j].callback_id, "exit-button") {
						current_screen = 0
					}*/
		    }
			}

		// Settings screen
		} else if current_screen == 3 {
			for i:=0; i<len(screens[i].layers); i++ {
				if screens[3].layers[i].pending_callback {
					screens[3].layers[i].pending_callback = false

					if str.eq(screens[3].layers[i].callback_id, "cancel-button") {
						current_screen = 0
					} else if str.eq(screens[3].layers[i].callback_id, "save-button") {
						current_screen = 0
					}
				}
			}
		}

		x, y = glfw.GetCursorPos("window")
		screens[current_screen] = screens[current_screen].update(f64.i32(x), f64.i32(y))

		gl.Clear(i32.bitor(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT))
		gl.LoadIdentity()

		gl.Disable(gl.DEPTH_TEST)
		screens[current_screen].render()
		gl.Enable(gl.DEPTH_TEST)

		if current_screen == 1 {
			game.render(program)
		}

		glfw.PollEvents()
		glfw.SwapBuffers("window")
	}
}
