package main

// Import core packages
import "gl"
import "glfw"
import "os"

// Import custom packages
import "graphical"
import "image_pkg"
import "button_pkg"
import "textbox_pkg"
import "layer_pkg"
import "screen_pkg"

// Keyboard Keys
var RIGHT_ARROW_KEY i32 = 262
var LEFT_ARROW_KEY i32 = 263
var DOWN_ARROW_KEY i32 = 264
var UP_ARROW_KEY i32 = 265

var rotate_x f32 = 25.0
var rotate_y f32 = 0.0
var rotate_z f32 = 25.0
var scale f32 = 1.5

// Directions
var UP i32 = 1
var DOWN i32 = 3
var LEFT i32 = 2
var RIGHT i32 = 0

// Screens
var SCREEN_WIDTH i32 = 1920
var SCREEN_HEIGHT i32 = 1080
var current_screen i32 = 0
var screens [4]screen_pkg.Screen

/* Function     : initGLFW
   Desctription : Initializes the game window and input callback functions.
*/
func initGLFW() {
	glfw.Init()
	glfw.WindowHint(glfw.Resizable, glfw.False)
	glfw.WindowHint(glfw.ContextVersionMajor, 2)
  glfw.WindowHint(glfw.ContextVersionMinor, 1)

	glfw.CreateWindow("window", SCREEN_WIDTH, SCREEN_HEIGHT, "PACMAN 3D") // TODO add fullscreen support
	glfw.MakeContextCurrent("window")

	glfw.SetKeyCallback("window", "keyboardManager")
	//glfw.SetCursorPosCallback("window", "cursor_pos_callback")
	glfw.SetMouseButtonCallback("window", "mouse_button_callback")
}

/* Function     : initOpenGL
   Output       : OpenGL program (program i32)
   Desctription : Initializes the OpenGL lib.
*/
func initGL() (program i32) {
	gl.Init()
	gl.Enable(gl.BLEND)
  gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	gl.Enable(gl.DEPTH_TEST)
	gl.Enable(gl.TEXTURE_2D)

	program = gl.CreateProgram()
	gl.LinkProgram(program)
	return program
}

func keyboardManager(window str, key i32, scancode i32, action i32, mods i32) () {
	if bool.and(i32.eq(key, RIGHT_ARROW_KEY), i32.eq(action, 1)) {
    player.direction = RIGHT
  }
  if bool.and(i32.eq(key, LEFT_ARROW_KEY), i32.eq(action, 1)) {
		player.direction = LEFT
  }
  if bool.and(i32.eq(key, DOWN_ARROW_KEY), i32.eq(action, 1)) {
		player.direction = DOWN
  }
  if bool.and(i32.eq(key, UP_ARROW_KEY), i32.eq(action, 1)) {
		player.direction = UP
  }
}

func canMove(direction i32, line i32, collumn i32) (can_move bool)  {
  var can_move bool = false
  if bool.and(i32.eq(direction, UP), bool.not(i32.eq(cells[i32.sub(line, 1)][collumn].ctype, WALL_CELL))) {
    can_move = true
  }
  if bool.and(i32.eq(direction, DOWN), bool.not(i32.eq(cells[i32.add(line, 1)][collumn].ctype, WALL_CELL))) {
    can_move = true
  }
  if bool.and(i32.eq(direction, LEFT), bool.not(i32.eq(cells[line][i32.sub(collumn, 1)].ctype, WALL_CELL))) {
    can_move = true
  }
  if bool.and(i32.eq(direction, RIGHT), bool.not(i32.eq(cells[line][i32.add(collumn, 1)].ctype, WALL_CELL))) {
    can_move = true
  }
  return can_move
}

var mouse_clicked bool = false
func mouse_button_callback(window str, key i32, action i32, mods i32) () {
	if i32.eq(action, 1) && i32.eq(key, glfw.MouseButtonLeft) {
    screens[current_screen] = screen_pkg.clickScreen(screens[current_screen])
	}

	if (action == 0) {
		mouse_clicked = false
	} else {
		mouse_clicked = true
	}
}

var old_x f64
func cursor_pos_callback(window str, xpos f64, ypos f64) () {
	if mouse_clicked {
		rotate_z = rotate_z + 0.2*f64.f32(xpos - old_x)
	}
	old_x = xpos
}

/* GAME LOGIC */

var player Player
var board Board

var x_cells i32 = 28
var y_cells i32 = 31
var cells [31][28]Cell

var simple_points []SimplePoint
var super_points 	[]SuperPoint

var ghosts [4]Ghost

func get_board_line(i i32) (line [28]i32) {
    if i32.eq(i, 1) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 2) {
      line = [28]i32{1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1}
    }
    if i32.eq(i, 3) {
      line = [28]i32{1,  2,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  2,  1}
    }
    if i32.eq(i, 4) {
      line = [28]i32{1,  0,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  0,  1}
    }
    if i32.eq(i, 5) {
      line = [28]i32{1,  0,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  0,  1}
    }
    if i32.eq(i, 6) {
      line = [28]i32{1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1}
    }
    if i32.eq(i, 7) {
      line = [28]i32{1,  0,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  0,  1}
    }
    if i32.eq(i, 8) {
      line = [28]i32{1,  0,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  0,  1}
    }
    if i32.eq(i, 9) {
      line = [28]i32{1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  1}
    }
    if i32.eq(i, 10) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  3,  1,  1,  3,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 11) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  3,  1,  1,  3,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 12) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 13) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  1,  1,  1,  1,  1,  1,  1,  1,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 14) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  1,  3,  3,  3,  3,  3,  3,  1,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 15) {
      line = [28]i32{3,  3,  3,  3,  3,  1,  0,  3,  3,  3,  1,  3,  3,  3,  3,  3,  3,  1,  3,  3,  3,  0,  1,  3,  3,  3,  3,  3}
    }
    if i32.eq(i, 16) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  1,  3,  3,  3,  3,  3,  3,  1,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 17) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  1,  1,  1,  1,  1,  1,  1,  1,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 18) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 19) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  1,  1,  1,  1,  1,  1,  1,  1,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 20) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  0,  1,  1,  3,  1,  1,  1,  1,  1,  1,  1,  1,  3,  1,  1,  0,  1,  1,  1,  1,  1,  1}
    }
    if i32.eq(i, 21) {
      line = [28]i32{1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1}
    }
    if i32.eq(i, 22) {
      line = [28]i32{1,  0,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  0,  1}
    }
    if i32.eq(i, 23) {
      line = [28]i32{1,  0,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  0,  1}
    }
    if i32.eq(i, 24) {
      line = [28]i32{1,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  3,  3,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  1}
    }
    if i32.eq(i, 25) {
      line = [28]i32{1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1}
    }
    if i32.eq(i, 26) {
      line = [28]i32{1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1}
    }
    if i32.eq(i, 27) {
      line = [28]i32{1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  1}
    }
    if i32.eq(i, 28) {
      line = [28]i32{1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1}
    }
    if i32.eq(i, 29) {
      line = [28]i32{1,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  1}
    }
    if i32.eq(i, 30) {
      line = [28]i32{1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1}
    }
    if i32.eq(i, 31) {
      line = [28]i32{1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1}
    }
    return line
}

// Item Types
var PATH_CELL i32 = 3
var WALL_CELL i32 = 1
var PATH_CELL_WITH_SIMPLE_POINT i32 = 0
var PATH_CELL_WITH_SUPER_POINT i32 = 2
var TELEPORT_CELL i32 = 4
var GATE_CELL i32 = 5

func getPosition3D(line i32, collumn i32) (v graphical.Vector3f) {
  x := f32.add(-1.0, f32.add(f32.mul(i32.f32(collumn), CELL_WIDTH), f32.div(CELL_WIDTH, 2.0)))
  y := f32.add(-1.0, f32.add(f32.mul(i32.f32(line), CELL_HEIGHT), f32.div(CELL_HEIGHT, 2.0)))
	v = graphical.newVector3f(x, y, 0.0)
  return v
}

func initScene() () {
  var i i32
  var j i32

  // Initialize game board items
  var line [28]i32
  for i=0; i<y_cells; i++ {
    line = get_board_line(i32.add(i, 1))
    for j=0; j<x_cells; j++ {
      initializeItem(i, j, line[j])
    }
  }

	initGhosts()
}

func initGhosts() {
	loadGhostTextures()
	for i:=0; i<4; i++ {
		ghosts[i] = newGhost(13, 14, i)
	}
}

func initializeItem(line i32, col i32, item_type i32) () {
  if i32.eq(item_type, WALL_CELL) {
    cells[line][col] = newCell(line, col, WALL_CELL)
  }
	/*
  if i32.eq(item_type, PATH_CELL) {
    cells[line][col] = newCell(line, col, PATH_CELL)
  }*/
  if i32.eq(item_type, PATH_CELL_WITH_SIMPLE_POINT) {
		simple_points = append(simple_points, newSimplePoint(line, col))
  }
  if i32.eq(item_type, PATH_CELL_WITH_SUPER_POINT) {
		super_points = append(super_points, newSuperPoint(line, col))
  }
	/*
  if i32.eq(item_type, TELEPORT_CELL) { // FIX ME merge multiple cases together
    cells[line][col] = newCell(line, col, TELEPORT_CELL)
  }
  if i32.eq(item_type, GATE_CELL) {
    cells[line][col] = newCell(line, col, GATE_CELL)
  }*/
}

func main () () {
	initGLFW()
	var program i32
	program = initGL()

	// Initializes all the screens
	screens[0] = newHomeScreen(SCREEN_WIDTH, SCREEN_HEIGHT)
	screens[1] = newGameScreen(SCREEN_WIDTH, SCREEN_HEIGHT)
	screens[2] = newPauseScreen(SCREEN_WIDTH, SCREEN_HEIGHT)
	screens[3] = newSettingsScreen(SCREEN_WIDTH, SCREEN_HEIGHT)

	// Loads all the game textures
	loadPlayerTextures()
	loadCellTextures()
	loadPointTetures()

	player = newPlayer(23, 13)  // Initializes the player
	board = newBoard()

  initScene() // Initializes all game objects

	var time f64
	var x f64
  var y f64
	for bool.not(glfw.ShouldClose("window")) {
		time = glfw.GetTime()

		// Home screen
		if current_screen == 0 {
			for j:=0; j<len(screens[0].layers); j++ {
				if screens[0].layers[j].pending_callback {
		      screens[0].layers[j].pending_callback = false

					if str.eq(screens[0].layers[j].callback_id, "play-button") {
						current_screen = 1
					} else if str.eq(screens[0].layers[j].callback_id, "settings-button") {
						current_screen = 3
					}
		    }
			}

		// Game screen
		} else if current_screen == 1 {
			for j:=0; j<len(screens[1].layers); j++ {
				if screens[1].layers[j].pending_callback {
		      screens[1].layers[j].pending_callback = false

					if str.eq(screens[1].layers[j].callback_id, "pause-button") {
						current_screen = 2
					}
					// FIXME @galah4d redirect to home screen, OpenGl crashes.
					/*else if str.eq(screens[2].layers[j].callback_id, "exit-button") {
						current_screen = 0
					}*/
		    }
			}

			player = player.update(time)
			for i:=0; i<len(simple_points); i++ {
				simple_points[i] = simple_points[i].update(player.index_x, player.index_y, time)
			}
			for i=0; i<len(super_points); i++ {
				super_points[i] = super_points[i].update(player.index_x, player.index_y, time)
			}
			var g Ghost
			for i=0; i<4; i++ {
				g = ghosts[i]
				ghosts[i] = g.update(time)
			}

		// Pause screen
		} else if current_screen == 2 {
			for j:=0; j<len(screens[2].layers); j++ {
				if screens[2].layers[j].pending_callback {
		      screens[2].layers[j].pending_callback = false

					if str.eq(screens[2].layers[j].callback_id, "resume-button") {
						current_screen = 1
					}
					// FIXME @galah4d redirect to home screen, OpenGl crashes.
					/*else if str.eq(screens[2].layers[j].callback_id, "exit-button") {
						current_screen = 0
					}*/
		    }
			}

		// Settings screen
		} else if current_screen == 3 {
			for i:=0; i<len(screens[i].layers); i++ {
				if screens[3].layers[i].pending_callback {
					screens[3].layers[i].pending_callback = false

					if str.eq(screens[3].layers[i].callback_id, "cancel-button") {
						current_screen = 0
					} else if str.eq(screens[3].layers[i].callback_id, "save-button") {
						current_screen = 0
					}
				}
			}
		}

		x, y = glfw.GetCursorPos("window")
		screens[current_screen] = screens[current_screen].update(f64.i32(x), f64.i32(y))

		gl.Clear(i32.bitor(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT))
		gl.LoadIdentity()

		gl.Disable(gl.DEPTH_TEST)
		screens[current_screen].render()
		gl.Enable(gl.DEPTH_TEST)

		if current_screen == 1 {
			var ratio f64
			ratio = f64.div(1920.0D, 1080.0D)
			gl.Ortho(
				-1.0D*ratio+f32.f64(player.geometry.position.x),
				1.0D*ratio+f32.f64(player.geometry.position.x),
				1.0D+f32.f64(player.geometry.position.y),
				-1.0D+f32.f64(player.geometry.position.y),
				-1.0D,
				1.0D)

			// Scales and rotates the scene
			gl.Scalef(scale, scale, scale);
			gl.Rotatef( rotate_x, 1.0, 0.0, 0.0 );
			gl.Rotatef( rotate_y, 0.0, 1.0, 0.0 );
			gl.Rotatef( rotate_z, 0.0, 0.0, 1.0 );

			gl.UseProgram(program)

			board.render()
			player.render()

			for i:=0; i<len(simple_points); i++ {
				simple_points[i].render()
			}
			for i=0; i<len(super_points); i++ {
				super_points[i].render()
			}

			//var g Ghost
			for i=0; i<4; i++ {
				//ghosts[0].render() THROWS AN ERROR
				g = ghosts[i]
				g.render()
			}
		}

		glfw.PollEvents()
		glfw.SwapBuffers("window")
	}
}
